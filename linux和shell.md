# linux和shell

## linux

- linux权限

r读权限 4，w写权限2，x执行权限1

- 正则表达式

是记录文本规则的代码，匹配语法，正则演练在线环境 https://tool.oschina.net/regex

- 查看当前环境中所有的环境变量

env



## SHELL&BASH

### 什么是shell

SHELL语言是指UNIX操作系统的命令语言,同时又是该命令语言的解释程序的简称。 Shell本身是一个用C语言编写的程序,它是用户使用Unix/Linux的桥梁,用户的大部分工作都是通过Shell完成的。Shell既是一种命令语言,又是一种程序设计语言

### 什么是bash

bash 是borne again shell的缩写,它是shell的一种,Linux上默认采用的是bash

当你在命令行中敲入bash命令时,相当于进入bash环境,如果本身就是bash环境,那么就是进入一个子bash环境(相当于开了一个子进程)

备注：编写shell脚本的时候，最前面要加上一行：`#!/bin/bash`，因为linux里面不仅仅只有bash一个解析器，还有其它的，它们之间的语法会有一些不同，所以最好加上这一句话，告诉系统要用这个解析器

查看当前系统有哪些shell

cat /etc/shells 

查看当前使用的shell

echo $SHELL

查看环境变量中的shell

env | grep SHELL



## linux三剑客与管道

### 管道

|，管道符左边的内容会作为右边命令的输入

### 正则

正则表达式是记录文本规则的代码

#### 常用匹配符

\b：单词的开始或者结束，加在单词后者字符左右两边，可以匹配单词或者字符两边为空或者是空格的情况

.*：匹配任意数量的任意符号（除换行符以外）

\d：匹配1个数字

\s：匹配1个空白字符（可以和*匹配匹配多个空格）

\w：匹配1个字母，数字，下划线或者汉字

^：行首

$：行尾

#### 常用限定符

*：零次或者多次

+：一次或者多次

?：零次或者一次

{n}：n次

{n,}：n次或者更多次

{n,m}：n到m次

### grep

常用参数

-v 显示没有被pattern匹配到的行(经常使用在“ps | grep | grep -v“ 过滤grep自身进程)

-i 忽略字符大小写

-n 显示匹配的行号

-c 统计匹配或者未匹配到行数(是否使用-v)

-o 仅显示匹配到的字符串

-E 使用ERE,相当于egrep

### sed

流编辑器，一次处理一行内容

格式：sed[][][-hn] \[-e\<script>] \[-f\<scriptFile>] \[FILE]

-h 显示帮助

-n 仅显示script处理后的结果

查找第n~m行的内容

#### 常用动作

a：新增， sed -e '4 a newline'，在第四行后增加a后面的内容(mac运行有问题，ubuntu没问题)

c：取代， sed -e '2,5c No 2-5 number'， 使用c后面的内容取代2到5行的内容

d：删除， sed -e '2,5d'，删除2到5行

-i：插入，sed -e '2i newline'，在第二行前插入i后面的内容

p：打印，sed -n '/root/p'，匹配root并打印

s：替换，sed -e 's/old/new/g'，匹配old并使用new进行取代，g代表全局替换，不加则替换第一次匹配内容

==以上所有命令均不会影响原有文件内容，源文件要改变要加-i参数，但是需要谨慎使用==

### awk

把文件逐行地读入，以空格为默认分隔符将每行切片，切开的部分再进行后续处理

格式：awk \[pattern+action] FILE

示例1：awk -F: '/root/ {print $7}' /etc/passwd，匹配/etc/password文件中包含root的行，并使用 ==:== 进行切片，打印第7个元素

示例2：awk -F: 'NR=2{print $0}' /etc/passwd, 打印文件中第二行内容

示例3：awk 'BEGIN {print "先执行一次BEGIN脚本"}{print $0}' /etc/passwd，先执行一次BEGIN后的脚本，然后再执行下一个脚本

示例4：echo "1122|333|444" | awk 'BEGIN{RS="|"}{print $0}'， 使用自定义记录分隔符|，将文本切割后，打印$0会以换行方式展示所有切割结果，打印$2会打印第二个元素

示例5：echo "1122|333|444" | awk -F":" {'print$2'}，使用自定义域分隔符切割文本后，打印$0会打印原来文本，打印$2会打印第二个元素

备注：$0表示整行内容，第一个元素从$1开始

